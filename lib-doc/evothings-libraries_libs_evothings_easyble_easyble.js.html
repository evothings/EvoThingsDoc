<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 3.4.0">
  <meta charset="utf-8">
  <title>Source: evothings-libraries/libs/evothings/easyble/easyble.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: evothings-libraries/libs/evothings/easyble/easyble.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>// File: easyble.js updated 160713

;(function()
{
	// Load script used by this file.
	evothings.loadScript(&#x27;libs/evothings/util/util.js&#x27;);

	/**
	 * @namespace
	 * @description &amp;lt;p&gt;Library for making BLE programming easier.&amp;lt;/p&gt;
	 * &amp;lt;p&gt;An all-in-one file with this library and helper libraries included is
	 * available in file &amp;lt;a href&#x3D;&quot;&quot;https://github.com/evothings/evothings-libraries/blob/master/libs/evothings/easyble/easyble.dist.js&gt;easyble.dist.js&amp;lt;/a&gt;. Include this file in index.html (recommended).&amp;lt;/p&gt;
	 * &amp;lt;p&gt;If you include &amp;lt;code&gt;easyble.js&amp;lt;/code&gt; rather than &amp;lt;code&gt;easyble.dist.js&amp;lt;/code&gt; it is safe practise to call function {@link evothings.scriptsLoaded}
	 * to ensure dependent libraries are loaded before calling functions
	 * in this library (in this case you also need to have the dependent library folders).&amp;lt;/p&gt;
	 */
	evothings.easyble &#x3D; {};

	/**
	 * @namespace
	 * @description Error string.
	 */
	evothings.easyble.error &#x3D; {};

	/**
	 * @description BLE device already connected.
	 */
	evothings.easyble.error.DEVICE_ALREADY_CONNECTED &#x3D; &#x27;EASYBLE_ERROR_DEVICE_ALREADY_CONNECTED&#x27;;

	/**
	 * @description BLE device was disconnected.
	 */
	evothings.easyble.error.DISCONNECTED &#x3D; &#x27;EASYBLE_ERROR_DISCONNECTED&#x27;;

	/**
	 * @description BLE service was not found.
	 */
	evothings.easyble.error.SERVICE_NOT_FOUND &#x3D; &#x27;EASYBLE_ERROR_SERVICE_NOT_FOUND&#x27;;

	/**
	 * @description BLE characteristic was not found.
	 */
	evothings.easyble.error.CHARACTERISTIC_NOT_FOUND &#x3D; &#x27;EASYBLE_ERROR_CHARACTERISTIC_NOT_FOUND&#x27;;

	/**
	 * @description BLE descriptor was not found.
	 */
	evothings.easyble.error.DESCRIPTOR_NOT_FOUND &#x3D; &#x27;EASYBLE_ERROR_DESCRIPTOR_NOT_FOUND&#x27;;

	/**
	 * @private
	 * This variable is set &quot;lazily&quot;, because when this script is loaded
	 * the Base64 Cordova module may not be loaded yet.
	 */
	var base64;

	/**
	 * Set to true to report found devices only once,
	 * set to false to report continuously.
	 * @private
	 */
	var reportDeviceOnce &#x3D; false;

	/**
	 * @private
	 */
	var serviceFilter &#x3D; false;

	/**
	 * @private
	 */
	var isScanning &#x3D; false;

	/**
	 * Internal properties and functions.
	 * @private
	 */
	var internal &#x3D; {};

	/**
	 * Internal variable used to track reading of service data.
	 * @private
	 */
	var readCounter &#x3D; 0;

	/**
	 * Table of discovered devices.
	 * @private
	 */
	internal.knownDevices &#x3D; {};

	/**
	 * Table of connected devices.
	 * @private
	 */
	internal.connectedDevices &#x3D; {};

	/**
	 * @description &amp;lt;strong&gt;Deprecated.&amp;lt;/strong&gt; Set whether to report devices once or continuously during scan.
	 * The default is to report continously.
	 * @deprecated Use the options parameter {@link evothings.easyble.ScanOptions} in
	 * function {@link evothings.easyble.startScan}.
	 * @param {boolean} reportOnce - Set to true to report found devices only once.
	 * Set to false to report continuously.
	 * @public
	 */
	evothings.easyble.reportDeviceOnce &#x3D; function(reportOnce)
	{
		reportDeviceOnce &#x3D; reportOnce;
	};

	/**
	 * @description Set to an Array of UUID strings to enable filtering of devices
	 * found by startScan().
	 * @param services - Array of UUID strings. Set to false to disable filtering.
	 * The default is no filtering. An empty array will cause no devices to be reported.
	 * @public
	 */
	evothings.easyble.filterDevicesByService &#x3D; function(services)
	{
		serviceFilter &#x3D; services;
	};

	/**
	 * @description Called during scanning when a BLE device is found.
	 * @callback evothings.easyble.scanCallback
	 * @param {evothings.easyble.EasyBLEDevice} device - EasyBLE device object
	 * found during scanning.
	 */

	/**
	 * @description This callback indicates that an operation was successful,
	 * without specifying and additional information.
	 * @callback evothings.easyble.emptyCallback - Callback that takes no parameters.
	 */

	/**
	 * @description This function is called when an operation fails.
	 * @callback evothings.easyble.failCallback
	 * @param {string} errorString - A human-readable string that
	 * describes the error that occurred.
	 */

	/**
	 * @description Called when successfully connected to a device.
	 * @callback evothings.easyble.connectCallback
	 * @param {evothings.easyble.EasyBLEDevice} device - EasyBLE devices object.
	 */

	/**
	 * @description Called when services are successfully read.
	 * @callback evothings.easyble.servicesCallback
	 * @param {evothings.easyble.EasyBLEDevice} device - EasyBLE devices object.
	 */

	/**
	 * @description Function when data is available.
	 * @callback evothings.easyble.dataCallback
	 * @param {ArrayBuffer} data - The data is an array buffer.
	 * Use an ArrayBufferView to access the data.
	 */

	/**
	 * @description Called with RSSI value.
	 * @callback evothings.easyble.rssiCallback
	 * @param {number} rssi - A negative integer, the signal strength in decibels.
	 * This value may be 127 which indicates an unknown value.
	 */

	/**
	 * @typedef {Object} evothings.easyble.ScanOptions
	 * @description Options for function {evothings.easyble.startScan}
	 * @property {array} serviceUUIDs - Array with strings of service UUIDs
	 * to scan for. When providing one service UUID, behaviour is the same on
	 * Android and iOS, when providing multiple UUIDs behaviour differs between
	 * platforms.
	 * On iOS multiple UUIDs are scanned for using logical OR operator,
	 * any UUID that matches any of the UUIDs adverticed by the device
	 * will count as a match. On Android, multiple UUIDs are scanned for
	 * using AND logic, the device must advertise all of the given UUIDs
	 * to produce a match. Leaving out this parameter or setting it to null
	 * will scan for all devices regardless of advertised services (default
	 * behaviour).
	 * @property {boolean} allowDuplicates - If true same device will be reported
	 * repeatedly during scanning, if false it will only be reported once.
	 * Default is true.
	 */

	/**
	 * Start scanning for devices. Note that the optional parameter serviceUUIDs
	 * has been deprecated. Please use the options parmameter
	 * {@link evothings.easyble.ScanOptions} instead to specify any specific
	 * service UUID to scan for.
	 * @param {evothings.easyble.scanCallback} success - Success function called when a
	 * device is found.
	 * Format: success({@link evothings.easyble.EasyBLEDevice}).
	 * @param {evothings.easyble.failCallback} fail - Error callback: fail(error).
	 * @param {evothings.easyble.ScanOptions} [options] - Object with scan options.
	 * @public
	 * @example
	 *   // Scan for all services.
	 *   evothings.easyble.startScan(
	 *       function(device)
	 *       {
	 *           console.log(&#x27;Found device named: &#x27; + device.name);
	 *       },
	 *       function(errorCode)
	 *       {
	 *           console.log(&#x27;startScan error: &#x27; + errorCode);
	 *       }
	 *   );
	 *
	 *   // Scan for specific service.
	 *   evothings.easyble.startScan(
	 *       function(device)
	 *       {
	 *           console.log(&#x27;Found device named: &#x27; + device.name);
	 *       },
	 *       function(errorCode)
	 *       {
	 *           console.log(&#x27;startScan error: &#x27; + errorCode);
	 *       },
	 *       // Eddystone service UUID specified in options.
	 *       { serviceUUIDs: [&#x27;0000FEAA-0000-1000-8000-00805F9B34FB&#x27;] }
	 *   );
	 */
	evothings.easyble.startScan &#x3D; function(arg1, arg2, arg3, arg4)
	{
		// Stop ongoing scan.
		evothings.easyble.stopScan();

		// Clear list of found devices.
		internal.knownDevices &#x3D; {};

		// Scanning parameters.
		var serviceUUIDs;
		var success;
		var fail;
		var options;
		var allowDuplicates &#x3D; undefined;

		// Determine parameters.
		if (Array.isArray(arg1))
		{
			// First param is an array of serviceUUIDs.
			serviceUUIDs &#x3D; arg1;
			success &#x3D; arg2;
			fail &#x3D; arg3;
			options &#x3D; arg4;
		}
		else if (&#x27;function&#x27; &#x3D;&#x3D; typeof arg1)
		{
			// First param is a function.
			serviceUUIDs &#x3D; null;
			success &#x3D; arg1;
			fail &#x3D; arg2;
			options &#x3D; arg3;
		}

		// Set options.
		if (options)
		{
			if (Array.isArray(options.serviceUUIDs))
			{
				serviceUUIDs &#x3D; options.serviceUUIDs;
			}

			if (options.allowDuplicates &#x3D;&#x3D;&#x3D; true)
			{
				allowDuplicates &#x3D; true;
			}
			else if (options.allowDuplicates &#x3D;&#x3D;&#x3D; false)
			{
				allowDuplicates &#x3D; false;
			}
		}

		// Start scanning.
		isScanning &#x3D; true;
		if (Array.isArray(serviceUUIDs))
		{
			evothings.ble.startScan(serviceUUIDs, onDeviceFound, onError);
		}
		else
		{
			evothings.ble.startScan(onDeviceFound, onError);
		}

		function onDeviceFound(device)
		{
			// Don&#x27;t report devices unless the isScanning flag is true.
			// This is to prevent devices being reported after stopScanning
			// has been called (this can happen since scanning does not stop
			// instantly when evothings.ble.stopScan is called).
			if (!isScanning) return;

			// Ensure we have advertisementData.
			internal.ensureAdvertisementData(device);

			// Check if the device matches the filter, if we have a filter.
			if (!internal.deviceMatchesServiceFilter(device))
			{
				return;
			}

			// Check if we already have got the device.
			var existingDevice &#x3D; internal.knownDevices[device.address]
			if (existingDevice)
			{
				// Do not report device again if flag is set.
				if (allowDuplicates &#x3D;&#x3D;&#x3D; false || reportDeviceOnce &#x3D;&#x3D;&#x3D; true) { return; }

				// Duplicates allowed, report device again.
				existingDevice.rssi &#x3D; device.rssi;
				existingDevice.name &#x3D; device.name;
				existingDevice.scanRecord &#x3D; device.scanRecord;
				existingDevice.advertisementData &#x3D; device.advertisementData;
				success(existingDevice);

				return;
			}

			// New device, add to known devices.
			internal.knownDevices[device.address] &#x3D; device;

			// Set connect status.
			device.__isConnected &#x3D; false;

			// Add methods to the device info object.
			internal.addMethodsToDeviceObject(device);

			// Call callback function with device info.
			success(device);
		}

		function onError(errorCode)
		{
			fail(errorCode);
		}
	};

	/**
	 * Stop scanning for devices.
	 * @example
	 *   evothings.easyble.stopScan();
	 */
	evothings.easyble.stopScan &#x3D; function()
	{
		isScanning &#x3D; false;
		evothings.ble.stopScan();
	};

	/**
	 * Disconnect and close all connected BLE devices.
	 * @example
	 *   evothings.easyble.closeConnectedDevices();
	 */
	evothings.easyble.closeConnectedDevices &#x3D; function()
	{
		for (var key in internal.connectedDevices)
		{
			var device &#x3D; internal.connectedDevices[key];
			device &amp;amp;&amp;amp; device.close();
			internal.connectedDevices[key] &#x3D; null;
		}
	};

	/**
	 * If device already has advertisementData, does nothing.
	 * If device instead has scanRecord, creates advertisementData.
	 * See ble.js for AdvertisementData reference.
	 * @param device - Device object.
	 * @private
	 */
	internal.ensureAdvertisementData &#x3D; function(device)
	{
		if (!base64) { base64 &#x3D; cordova.require(&#x27;cordova/base64&#x27;); }

		// If device object already has advertisementData we
		// do not need to parse the scanRecord.
		if (device.advertisementData) { return; }

		// Must have scanRecord yo continue.
		if (!device.scanRecord) { return; }

		// Here we parse BLE/GAP Scan Response Data.
		// See the Bluetooth Specification, v4.0, Volume 3, Part C, Section 11,
		// for details.

		var byteArray &#x3D; evothings.util.base64DecToArr(device.scanRecord);
		var pos &#x3D; 0;
		var advertisementData &#x3D; {};
		var serviceUUIDs;
		var serviceData;

		// The scan record is a list of structures.
		// Each structure has a length byte, a type byte, and (length-1) data bytes.
		// The format of the data bytes depends on the type.
		// Malformed scanRecords will likely cause an exception in this function.
		while (pos &amp;lt; byteArray.length)
		{
			var length &#x3D; byteArray[pos++];
			if (length &#x3D;&#x3D; 0)
			{
				break;
			}
			length -&#x3D; 1;
			var type &#x3D; byteArray[pos++];

			// Parse types we know and care about.
			// Skip other types.

			var BLUETOOTH_BASE_UUID &#x3D; &#x27;-0000-1000-8000-00805f9b34fb&#x27;

			// Convert 16-byte Uint8Array to RFC-4122-formatted UUID.
			function arrayToUUID(array, offset)
			{
				var k&#x3D;0;
				var string &#x3D; &#x27;&#x27;;
				var UUID_format &#x3D; [4, 2, 2, 2, 6];
				for (var l&#x3D;0; l&amp;lt;UUID_format.length; l++)
				{
					if (l !&#x3D; 0)
					{
						string +&#x3D; &#x27;-&#x27;;
					}
					for (var j&#x3D;0; j&amp;lt;UUID_format[l]; j++, k++)
					{
						string +&#x3D; evothings.util.toHexString(array[offset+k], 1);
					}
				}
				return string;
			}

			if (type &#x3D;&#x3D; 0x02 || type &#x3D;&#x3D; 0x03) // 16-bit Service Class UUIDs.
			{
				serviceUUIDs &#x3D; serviceUUIDs ? serviceUUIDs : [];
				for(var i&#x3D;0; i&amp;lt;length; i+&#x3D;2)
				{
					serviceUUIDs.push(
						&#x27;0000&#x27; +
						evothings.util.toHexString(
							evothings.util.littleEndianToUint16(byteArray, pos + i),
							2) +
						BLUETOOTH_BASE_UUID);
				}
			}
			if (type &#x3D;&#x3D; 0x04 || type &#x3D;&#x3D; 0x05) // 32-bit Service Class UUIDs.
			{
				serviceUUIDs &#x3D; serviceUUIDs ? serviceUUIDs : [];
				for (var i&#x3D;0; i&amp;lt;length; i+&#x3D;4)
				{
					serviceUUIDs.push(
						evothings.util.toHexString(
							evothings.util.littleEndianToUint32(byteArray, pos + i),
							4) +
						BLUETOOTH_BASE_UUID);
				}
			}
			if (type &#x3D;&#x3D; 0x06 || type &#x3D;&#x3D; 0x07) // 128-bit Service Class UUIDs.
			{
				serviceUUIDs &#x3D; serviceUUIDs ? serviceUUIDs : [];
				for (var i&#x3D;0; i&amp;lt;length; i+&#x3D;16)
				{
					serviceUUIDs.push(arrayToUUID(byteArray, pos + i));
				}
			}
			if (type &#x3D;&#x3D; 0x08 || type &#x3D;&#x3D; 0x09) // Local Name.
			{
				advertisementData.kCBAdvDataLocalName &#x3D; evothings.ble.fromUtf8(
					new Uint8Array(byteArray.buffer, pos, length));
			}
			if (type &#x3D;&#x3D; 0x0a) // TX Power Level.
			{
				advertisementData.kCBAdvDataTxPowerLevel &#x3D;
					evothings.util.littleEndianToInt8(byteArray, pos);
			}
			if (type &#x3D;&#x3D; 0x16) // Service Data, 16-bit UUID.
			{
				serviceData &#x3D; serviceData ? serviceData : {};
				var uuid &#x3D;
					&#x27;0000&#x27; +
					evothings.util.toHexString(
						evothings.util.littleEndianToUint16(byteArray, pos),
						2) +
					BLUETOOTH_BASE_UUID;
				var data &#x3D; new Uint8Array(byteArray.buffer, pos+2, length-2);
				serviceData[uuid] &#x3D; base64.fromArrayBuffer(data);
			}
			if (type &#x3D;&#x3D; 0x20) // Service Data, 32-bit UUID.
			{
				serviceData &#x3D; serviceData ? serviceData : {};
				var uuid &#x3D;
					evothings.util.toHexString(
						evothings.util.littleEndianToUint32(byteArray, pos),
						4) +
					BLUETOOTH_BASE_UUID;
				var data &#x3D; new Uint8Array(byteArray.buffer, pos+4, length-4);
				serviceData[uuid] &#x3D; base64.fromArrayBuffer(data);
			}
			if (type &#x3D;&#x3D; 0x21) // Service Data, 128-bit UUID.
			{
				serviceData &#x3D; serviceData ? serviceData : {};
				var uuid &#x3D; arrayToUUID(byteArray, pos);
				var data &#x3D; new Uint8Array(byteArray.buffer, pos+16, length-16);
				serviceData[uuid] &#x3D; base64.fromArrayBuffer(data);
			}
			if (type &#x3D;&#x3D; 0xff) // Manufacturer-specific Data.
			{
				// Annoying to have to transform base64 back and forth,
				// but it has to be done in order to maintain the API.
				advertisementData.kCBAdvDataManufacturerData &#x3D;
					base64.fromArrayBuffer(new Uint8Array(byteArray.buffer, pos, length));
			}

			pos +&#x3D; length;
		}
		advertisementData.kCBAdvDataServiceUUIDs &#x3D; serviceUUIDs;
		advertisementData.kCBAdvDataServiceData &#x3D; serviceData;
		device.advertisementData &#x3D; advertisementData;

		/*
		// Log raw data for debugging purposes.

		console.log(&quot;scanRecord: &quot;+evothings.util.typedArrayToHexString(byteArray));

		console.log(JSON.stringify(advertisementData));
		*/
	}

	/**
	 * Returns true if the device matches the serviceFilter, or if there is no filter.
	 * Returns false otherwise.
	 * @private
	 */
	internal.deviceMatchesServiceFilter &#x3D; function(device)
	{
		if (!serviceFilter) { return true; }

		var advertisementData &#x3D; device.advertisementData;
		if (advertisementData)
		{
			var serviceUUIDs &#x3D; advertisementData.kCBAdvDataServiceUUIDs;
			if (serviceUUIDs)
			{
				for (var i in serviceUUIDs)
				{
					for (var j in serviceFilter)
					{
						if (serviceUUIDs[i].toLowerCase() &#x3D;&#x3D;
							serviceFilter[j].toLowerCase())
						{
							return true;
						}
					}
				}
			}
		}
		return false;
	}

	/**
	 * Add functions to the device object to allow calling them
	 * in an object-oriented style.
	 * @private
	 */
	internal.addMethodsToDeviceObject &#x3D; function(deviceObject)
	{
		/**
		 * @namespace
		 * @alias evothings.easyble.EasyBLEDevice
		 * @description This is the BLE DeviceInfo object obtained from the
		 * underlying Cordova plugin.
		 * @property {string} address - Uniquely identifies the device.
		 * The form of the address depends on the host platform.
		 * @property {number} rssi - A negative integer, the signal strength in decibels.
		 * @property {string} name - The device&#x27;s name, or nil.
		 * @property {string} scanRecord - Base64-encoded binary data. Its meaning is
		 * device-specific. Not available on iOS.
		 * @property {evothings.easyble.AdvertisementData} advertisementData -
		 * Object containing some of the data from the scanRecord.
		 */
		var device &#x3D; deviceObject;

		/**
		 * @typedef {Object} evothings.easyble.AdvertisementData
		 * @description Information extracted from a scanRecord. Some or all of the fields may be
		 * undefined. This varies between BLE devices.
		 * Depending on OS version and BLE device, additional fields, not documented
		 * here, may be present.
		 * @property {string} kCBAdvDataLocalName - The device&#x27;s name. Use this field
		 * rather than device.name, since on iOS the device name is cached and changes
		 * are not reflected in device.name.
		 * @property {number} kCBAdvDataTxPowerLevel - Transmission power level as
		 * advertised by the device.
		 * @property {boolean} kCBAdvDataIsConnectable - True if the device accepts
		 * connections. False if it doesn&#x27;t.
		 * @property {array} kCBAdvDataServiceUUIDs - Array of strings, the UUIDs of
		 * services advertised by the device. Formatted according to RFC 4122,
		 * all lowercase.
		 * @property {object} kCBAdvDataServiceData - Dictionary of strings to strings.
		 * The keys are service UUIDs. The values are base-64-encoded binary data.
		 * @property {string} kCBAdvDataManufacturerData - Base-64-encoded binary data.
		 * This field is used by BLE devices to advertise custom data that don&#x27;t fit
		 * into any of the other fields.
		 */

		/**
		 * Get device name. If there is a device name present in
		 * advertisement data, this is returned. Otherwise the value of
		 * the device.name field is returned. Note that iOS caches the
		 * device.name field, but not the name in advertisement data.
		 * If you change name of the device, it is more reliable to use
		 * the field in advertisement data (this name is set in the device
		 * firmware code).
		 * @return Name of the device.
		 * @public
		 * @instance
		 * @example
		 *   var name &#x3D; device.getName();
		 */
		device.getName &#x3D; function()
		{
			// If there is a device name present in advertisement data,
			// check if this matches. (This name is not cached by iOS.)
			var deviceName &#x3D; device.advertisementData ?
				device.advertisementData.kCBAdvDataLocalName : false;
			if (deviceName)
			{
				return deviceName;
			}
			else
			{
				return device.name;
			}
		};

		/**
		 * Match device name. First checks the device name present in
		 * advertisement data, if not present checks device.name field.
		 * @param name The name to match.
		 * @return true if device has the given name, false if not.
		 * @public
		 * @instance
		 * @example
		 *   device.hasName(&#x27;MyBLEDevice&#x27;);
		 */
		device.hasName &#x3D; function(name)
		{
			// If there is a device name present in advertisement data,
			// check if this matches. (This name is not cached by iOS.)
			var deviceName &#x3D; device.advertisementData ?
				device.advertisementData.kCBAdvDataLocalName : false;
			if (deviceName) 
			{
				// TODO: This should be a comparison, but there has been
				// instances of the kCBAdvDataLocalName field ending with 
				// a non-printable character, using indexOf is a quick 
				// fix for this.
				return 0 &#x3D;&#x3D; deviceName.indexOf(name);
			}
			
			// Otherwise check if device.name matches (cached by iOS,
			// might not match if device name is updated).
			return name &#x3D;&#x3D; device.name;
		};

		/**
		 * Connect to the device.
		 * @param {evothings.easyble.connectCallback} success -
		 * Called when connected: success(device).
		 * @param {evothings.easyble.failCallback} fail -
		 * Called on error and if a disconnect happens.
		 * Format: error(errorMessage)
		 * @public
		 * @instance
		 * @example
		 *   device.connect(
		 *     function(device)
		 *     {
		 *       console.log(&#x27;device connected.&#x27;);
		 *       // Read services here.
		 *     },
		 *     function(errorCode)
		 *     {
		 *       console.log(&#x27;connect error: &#x27; + errorCode);
		 *     });
		 */
		device.connect &#x3D; function(success, fail)
		{
			internal.connectToDevice(device, success, fail);
		};

		/**
		 * Check if device is connected.
		 * @return true if connected, false if not connected.
		 * @public
		 * @instance
		 * @example
		 *   var connected &#x3D; device.isConnected();
		 */
		device.isConnected &#x3D; function()
		{
			return device.__isConnected;
		};

		/**
		 * Close the device. This disconnects from the BLE device.
		 * @public
		 * @instance
		 * @example
		 * device.close();
		 */
		device.close &#x3D; function()
		{
			if (device.deviceHandle)
			{
				device.__isConnected &#x3D; false;
				evothings.ble.close(device.deviceHandle);
			}
		};

		/**
		 * Read devices RSSI. Device must be connected.
		 * @param {evothings.easyble.rssiCallback} success - Callback called with
		 * RSSI value: success(rssi).
		 * @param {evothings.easyble.failCallback} fail - Called on error: fail(error).
		 * @public
		 * @instance
		 */
		device.readRSSI &#x3D; function(success, fail)
		{
			evothings.ble.rssi(device.deviceHandle, success, fail);
		};

		/**
		 * @typedef {Object} evothings.easyble.ReadServicesOptions
		 * @description Options object for function
		 * {@link evothings.easyble.EasyBLEDevice#readServices}
		 * @property {array} serviceUUIDs - Array of service UUID strings.
		 */

		/**
		 * Read services, characteristics and descriptors for the
		 * specified service UUIDs.
		 * &amp;lt;strong&gt;Services must be read be able to access characteristics and
		 * descriptors&amp;lt;/strong&gt;. Call this function before reading and writing
		 * characteristics/descriptors. (This function took an array of service
		 * UUIDs as first parameter in previous versions of this library, that
		 * is still supported for backwards compatibility but has ben deprecated.)
		 * @param {evothings.easyble.servicesCallback} success -
		 * Called when services are read: success(device)
		 * @param {evothings.easyble.failCallback} fail - error callback:
		 * error(errorMessage)
		 * @param {evothings.easyble.ReadServicesOptions} [options] - Optional
		 * object with setting that allow specification of which services to
		 * read. If left out, all services and related characteristics and
		 * descriptors are read (this can be time-consuming compared to
		 * reading selected services).
		 * @public
		 * @instance
		 * @example
		 *   // Read all services
		 *   device.readServices(
		 *     function(device)
		 *     {
		 *       console.log(&#x27;Services available.&#x27;);
		 *       // Read/write/enable notifications here.
		 *     },
		 *     function(errorCode)
		 *     {
		 *       console.log(&#x27;readServices error: &#x27; + errorCode);
		 *     });
		 *
		 *   // Read specific service
		 *   device.readServices(
		 *     function(device)
		 *     {
		 *       console.log(&#x27;Services available.&#x27;);
		 *       // Read/write/enable notifications here.
		 *     },
		 *     function(errorCode)
		 *     {
		 *       console.log(&#x27;readServices error: &#x27; + errorCode);
		 *     },
		 *     { serviceUUIDs: [&#x27;19b10000-e8f2-537e-4f6c-d104768a1214&#x27;] });
		 */
		device.readServices &#x3D; function(arg1, arg2, arg3, arg4)
		{
			// Parameters.
			var serviceUUIDs;
			var success;
			var fail;
			var options;

			// For backwards compatibility when first arg specified
			// an array of service UUIDs.
			if (Array.isArray(arg1))
			{
				serviceUUIDs &#x3D; arg1;
				success &#x3D; arg2;
				fail &#x3D; arg3;
				options &#x3D; arg4;
			}
			// Previously you could set first param to null to read all services.
			// Here we handle this case for backwards compatibility.
			else if (arg1 &#x3D;&#x3D;&#x3D; undefined || arg1 &#x3D;&#x3D;&#x3D; null)
			{
				serviceUUIDs &#x3D; null;
				success &#x3D; arg2;
				fail &#x3D; arg3;
				options &#x3D; arg4;
			}
			else
			{
				success &#x3D; arg1;
				fail &#x3D; arg2;
				options &#x3D; arg3;
			}

			if (options &amp;amp;&amp;amp; Array.isArray(options.serviceUUIDs))
			{
				serviceUUIDs &#x3D; options.serviceUUIDs;
			}

			internal.readServices(device, serviceUUIDs, success, fail);
		};

		/**
		 * Read value of characteristic.
		 * @param {string} serviceUUID - UUID of service that has the given
		 * characteristic (previous versions of this library allowed leaving out
		 * the service UUID, this is unsafe practice and has been deprecated, always
		 * specify the service UUID).
		 * @param {string} characteristicUUID - UUID of characteristic to read.
		 * @param {evothings.easyble.dataCallback} success - Success callback:
		 * success(data).
		 * @param {evothings.easyble.failCallback} fail - Error callback: fail(error).
		 * @public
		 * @instance
		 * @example
		 *   device.readCharacteristic(
		 *     serviceUUID,
		 *     characteristicUUID,
		 *     function(data)
		 *     {
		 *       console.log(&#x27;characteristic data: &#x27; + evothings.ble.fromUtf8(data));
		 *     },
		 *     function(errorCode)
		 *     {
		 *       console.log(&#x27;readCharacteristic error: &#x27; + errorCode);
		 *     });
		 */
		device.readCharacteristic &#x3D; function(arg1, arg2, arg3, arg4)
		{
			if (&#x27;function&#x27; &#x3D;&#x3D; typeof arg2)
			{
				// Service UUID is missing.
				internal.readCharacteristic(device, arg1, arg2, arg3);
			}
			else
			{
				// Service UUID is present.
				internal.readServiceCharacteristic(device, arg1, arg2, arg3, arg4);
			}
		};

		/**
		 * &amp;lt;strong&gt;Deprecated&amp;lt;/strong&gt;.
		 * Use function {@link evothings.easyble.EasyBLEDevice#readCharacteristic}
		 * @deprecated
		 * @instance
		 */
		device.readServiceCharacteristic &#x3D; function(
			serviceUUID, characteristicUUID, success, fail)
		{
			internal.readServiceCharacteristic(
				device, serviceUUID, characteristicUUID, success, fail);
		};

		/**
		 * Read value of descriptor.
		 * @param {string} serviceUUID - UUID of service that has the given
		 * characteristic (previous versions of this library allowed leaving out
		 * the service UUID, this is unsafe practice and has been deprecated, always
		 * specify the service UUID).
		 * @param {string} characteristicUUID - UUID of characteristic for descriptor.
		 * @param {string} descriptorUUID - UUID of descriptor to read.
		 * @param {evothings.easyble.dataCallback} success - Success callback:
		 * success(data).
		 * @param {evothings.easyble.failCallback} fail - Error callback: fail(error).
		 * @public
		 * @instance
		 * @example
		 *   device.readDescriptor(
		 *     serviceUUID,
		 *     characteristicUUID,
		 *     descriptorUUID,
		 *     function(data)
		 *     {
		 *       console.log(&#x27;descriptor data: &#x27; + evothings.ble.fromUtf8(data));
		 *     },
		 *     function(errorCode)
		 *     {
		 *       console.log(&#x27;readDescriptor error: &#x27; + errorCode);
		 *     });
		 */
		device.readDescriptor &#x3D; function(arg1, arg2, arg3, arg4, arg5)
		{
			if (&#x27;function&#x27; &#x3D;&#x3D; typeof arg3)
			{
				// Service UUID is missing.
				internal.readDescriptor(device, arg1, arg2, arg3, arg4);
			}
			else
			{
				// Service UUID is present.
				internal.readServiceDescriptor(device, arg1, arg2, arg3, arg4, arg5);
			}
		};

		/**
		 * &amp;lt;strong&gt;Deprecated&amp;lt;/strong&gt;.
		 * Use function {@link evothings.easyble.EasyBLEDevice#readDescriptor}
		 * @deprecated
		 * @instance
		 */
		device.readServiceDescriptor &#x3D; function(
			serviceUUID, characteristicUUID, descriptorUUID, success, fail)
		{
			internal.readServiceDescriptor(
				device, serviceUUID, characteristicUUID, descriptorUUID, success, fail);
		};

		/**
		 * Write value of characteristic.
		 * @param {string} serviceUUID - UUID of service that has the given
		 * characteristic (previous versions of this library allowed leaving out
		 * the service UUID, this is unsafe practice and has been deprecated, always
		 * specify the service UUID).
		 * @param {string} characteristicUUID - UUID of characteristic to write to.
		 * @param {ArrayBufferView} value - Value to write.
		 * @param {evothings.easyble.emptyCallback} success - Success callback: success().
		 * @param {evothings.easyble.failCallback} fail - Error callback: fail(error).
		 * @public
		 * @instance
		 * @example
		 *   device.writeCharacteristic(
		 *     serviceUUID,
		 *     characteristicUUID,
		 *     new Uint8Array([1]), // Write byte with value 1.
		 *     function()
		 *     {
		 *       console.log(&#x27;characteristic written.&#x27;);
		 *     },
		 *     function(errorCode)
		 *     {
		 *       console.log(&#x27;writeCharacteristic error: &#x27; + errorCode);
		 *     });
		 */
		device.writeCharacteristic &#x3D; function(arg1, arg2, arg3, arg4, arg5)
		{
			if (&#x27;function&#x27; &#x3D;&#x3D; typeof arg3)
			{
				// Service UUID is missing.
				internal.writeCharacteristic(device, arg1, arg2, arg3, arg4);
			}
			else
			{
				// Service UUID is present.
				internal.writeServiceCharacteristic(device, arg1, arg2, arg3, arg4, arg5);
			}
		};

		/**
		 * &amp;lt;strong&gt;Deprecated&amp;lt;/strong&gt;.
		 * Use function {@link evothings.easyble.EasyBLEDevice#writeCharacteristic}
		 * @deprecated
		 * @instance
		 */
		device.writeServiceCharacteristic &#x3D; function(
			serviceUUID, characteristicUUID, value, success, fail)
		{
			internal.writeServiceCharacteristic(
				device, serviceUUID, characteristicUUID, value, success, fail);
		};

		/**
		 * Write value of a characteristic for a specific service without response.
		 * This faster but not as fail safe as writing with response.
		 * Asks the remote device to NOT send a confirmation message.
		 * Experimental, implemented on Android.
		 * @param {string} serviceUUID - UUID of service that has the characteristic.
		 * @param {string} characteristicUUID - UUID of characteristic to write to.
		 * @param {ArrayBufferView} value - Value to write.
		 * @param {evothings.easyble.emptyCallback} success - Success callback: success().
		 * @param {evothings.easyble.failCallback} fail - Error callback: fail(error).
		 * @public
		 * @instance
		 * @example
		 *   device.writeCharacteristicWithoutResponse(
		 *     serviceUUID,
		 *     characteristicUUID,
		 *     new Uint8Array([1]), // Write byte with value 1.
		 *     function()
		 *     {
		 *       console.log(&#x27;data sent.&#x27;);
		 *     },
		 *     function(errorCode)
		 *     {
		 *       console.log(&#x27;writeCharacteristicWithoutResponse error: &#x27; + errorCode);
		 *     });
		 */
		device.writeCharacteristicWithoutResponse &#x3D; function(
			serviceUUID, characteristicUUID, value, success, fail)
		{
			internal.writeServiceCharacteristicWithoutResponse(
				device, serviceUUID, characteristicUUID, value, success, fail);
		};

		/**
		 * &amp;lt;strong&gt;Deprecated&amp;lt;/strong&gt;.
		 * Use function {@link evothings.easyble.EasyBLEDevice#writeCharacteristicWithoutResponse}
		 * @deprecated
		 * @instance
		 */
		device.writeServiceCharacteristicWithoutResponse &#x3D; function(
			serviceUUID, characteristicUUID, value, success, fail)
		{
			internal.writeServiceCharacteristicWithoutResponse(
				device, serviceUUID, characteristicUUID, value, success, fail);
		};

		/**
		 * Write value of descriptor.
		 * @param {string} serviceUUID - UUID of service that has the given
		 * characteristic (previous versions of this library allowed leaving out
		 * the service UUID, this is unsafe practice and has been deprecated, always
		 * specify the service UUID).
		 * @param {string} characteristicUUID - UUID of characteristic for descriptor.
		 * @param {string} descriptorUUID - UUID of descriptor to write to.
		 * @param {ArrayBufferView} value - Value to write.
		 * @param {evothings.easyble.emptyCallback} success - Success callback: success().
		 * @param {evothings.easyble.failCallback} fail - Error callback: fail(error).
		 * @public
		 * @instance
		 * @example
		 *   device.writeDescriptor(
		 *     serviceUUID,
		 *     characteristicUUID,
		 *     descriptorUUID,
		 *     new Uint8Array([1]), // Write byte with value 1.
		 *     function()
		 *     {
		 *       console.log(&#x27;descriptor written.&#x27;);
		 *     },
		 *     function(errorCode)
		 *     {
		 *       console.log(&#x27;writeDescriptor error: &#x27; + errorCode);
		 *     });
		 */
		device.writeDescriptor &#x3D; function(arg1, arg2, arg3, arg4, arg5, arg6)
		{
			if (&#x27;function&#x27; &#x3D;&#x3D; typeof arg4)
			{
				// Service UUID is missing.
				internal.writeDescriptor(device, arg1, arg2, arg3, arg4, arg5);
			}
			else
			{
				// Service UUID is present.
				internal.writeServiceDescriptor(device, arg1, arg2, arg3, arg4, arg5, arg6);
			}
		};

		/**
		 * &amp;lt;strong&gt;Deprecated&amp;lt;/strong&gt;.
		 * Use function {@link evothings.easyble.EasyBLEDevice#writeDescriptor}
		 * @deprecated
		 * @instance
		 */
		device.writeServiceDescriptor &#x3D; function(
			serviceUUID, characteristicUUID, descriptorUUID, value, success, fail)
		{
			internal.writeServiceDescriptor(
				device,
				serviceUUID,
				characteristicUUID,
				descriptorUUID,
				value,
				success,
				fail);
		};

		/**
		 * @typedef {Object} evothings.easyble.NotificationOptions
		 * @description Options object for functions
		 * {@link evothings.easyble.EasyBLEDevice#enableNotification}
		 * and {@link evothings.easyble.EasyBLEDevice#disableNotification}.
		 * @property {boolean} writeConfigDescriptor - Supported on Android, ignored on iOS.
		 * Set to false to disable automatic writing of notification or indication
		 * config descriptor value. This is useful in special cases when full control
		 * of writing the config descriptor is needed.
		 */

		/**
		 * Subscribe to value updates of a characteristic.
		 * The success function will be called repeatedly whenever there
		 * is new data available.
		 * &amp;lt;p&gt;On Android you can disable automatic write of notify/indicate and write
		 * the configuration descriptor yourself, supply an options object as
		 * last parameter, see example below.&amp;lt;/p&gt;
		 * @param {string} serviceUUID - UUID of service that has the given
		 * characteristic (previous versions of this library allowed leaving out
		 * the service UUID, this is unsafe practice and has been deprecated, always
		 * specify the service UUID).
		 * @param {string} characteristicUUID - UUID of characteristic to subscribe to.
		 * @param {evothings.easyble.dataCallback} success - Success callback:
		 * success(data).
		 * @param {evothings.easyble.failCallback} fail - Error callback: fail(error).
		 * @param {evothings.easyble.NotificationOptions} [options] -  Optional settings.
		 * @public
		 * @instance
		 * @example
		 * // Example call:
		 * device.enableNotification(
		 *   serviceUUID,
		 *   characteristicUUID,
		 *   function(data)
		 *   {
		 *     console.log(&#x27;characteristic data: &#x27; + evothings.ble.fromUtf8(data));
		 *   },
		 *   function(errorCode)
		 *   {
		 *     console.log(&#x27;enableNotification error: &#x27; + errorCode);
		 *   });
		 *
		 * // Turn off automatic writing of the config descriptor (for special cases):
		 * device.enableNotification(
		 *   serviceUUID,
		 *   characteristicUUID,
		 *   function(data)
		 *   {
		 *     console.log(&#x27;characteristic data: &#x27; + evothings.ble.fromUtf8(data));
		 *   },
		 *   function(errorCode)
		 *   {
		 *     console.log(&#x27;enableNotification error: &#x27; + errorCode);
		 *   },
		 *   { writeConfigDescriptor: false });
		 */
		device.enableNotification &#x3D; function(arg1, arg2, arg3, arg4, arg5)
		{
			if (&#x27;function&#x27; &#x3D;&#x3D; typeof arg2)
			{
				// Service UUID is missing.
				internal.enableNotification(device, arg1, arg2, arg3, arg4);
			}
			else
			{
				// Service UUID is present.
				internal.enableServiceNotification(device, arg1, arg2, arg3, arg4, arg5);
			}
		};

		/**
		 * &amp;lt;strong&gt;Deprecated&amp;lt;/strong&gt;.
		 * Use function {@link evothings.easyble.EasyBLEDevice#enableNotification}
		 * @deprecated
		 * @instance
		 */
		device.enableServiceNotification &#x3D; function(
			serviceUUID, characteristicUUID, success, fail, options)
		{
			internal.enableServiceNotification(
				device,
				serviceUUID,
				characteristicUUID,
				success,
				fail,
				options);
		};

		/**
		 * Unsubscribe from characteristic updates to stop notifications.
		 * &amp;lt;p&gt;On Android you can disable automatic write of notify/indicate and write
		 * the configuration descriptor yourself, supply an options object as
		 * last parameter, see example below.&amp;lt;/p&gt;
		 * @param {string} serviceUUID - UUID of service that has the given
		 * characteristic (previous versions of this library allowed leaving out
		 * the service UUID, this is unsafe practice and has been deprecated, always
		 * specify the service UUID).
		 * @param serviceUUID - UUID of service that has the given characteristic.
		 * @param characteristicUUID - UUID of characteristic to unsubscribe from.
		 * @param {evothings.easyble.emptyCallback} success - Success callback: success()
		 * @param {evothings.easyble.failCallback} fail - Error callback: fail(error)
		 * @param {evothings.easyble.NotificationOptions} [options] -  Optional settings.
		 * @public
		 * @instance
		 * @example
		 * // Example call:
		 * device.disableNotification(
		 *   serviceUUID,
		 *   characteristicUUID,
		 *   function()
		 *   {
		 *     console.log(&#x27;characteristic notification disabled&#x27;);
		 *   },
		 *   function(errorCode)
		 *   {
		 *     console.log(&#x27;disableNotification error: &#x27; + errorCode);
		 *   });
		 */
		device.disableNotification &#x3D; function(arg1, arg2, arg3, arg4, arg5)
		{
			if (&#x27;function&#x27; &#x3D;&#x3D; typeof arg2)
			{
				// Service UUID is missing.
				internal.disableNotification(device, arg1, arg2, arg3, arg4);
			}
			else
			{
				// Service UUID is present.
				internal.disableServiceNotification(device, arg1, arg2, arg3, arg4, arg5);
			}
		};

		/**
		 * &amp;lt;strong&gt;Deprecated&amp;lt;/strong&gt;.
		 * Use function {@link evothings.easyble.EasyBLEDevice#disableNotification}
		 * @deprecated
		 * @instance
		 */
		device.disableServiceNotification &#x3D; function(
			serviceUUID, characteristicUUID, success, fail, options)
		{
			internal.disableServiceNotification(
				device, serviceUUID, characteristicUUID, success, fail, options);
		};
	};

	/**
	 * Connect to a device.
 	 * Called from evothings.easyble.EasyBLEDevice.
	 * @private
	 */
	internal.connectToDevice &#x3D; function(device, success, fail)
	{
		// Check that device is not already connected.
		if (device.__isConnected)
		{
			fail(evothings.easyble.error.DEVICE_ALREADY_CONNECTED);
			return;
		}
		
		evothings.ble.connect(
			device.address,
			// Success callback.
			function(connectInfo)
			{
				// DEBUG LOG
				console.log(&#x27;BLE connect state: &#x27; + connectInfo.state);
			
				if (connectInfo.state &#x3D;&#x3D; 2) // connected
				{
					device.deviceHandle &#x3D; connectInfo.deviceHandle;
					device.__uuidMap &#x3D; {};
					device.__serviceMap &#x3D; {};
					device.__isConnected &#x3D; true;
					internal.connectedDevices[device.address] &#x3D; device;

					success(device);
				}
				else if (connectInfo.state &#x3D;&#x3D; 0) // disconnected
				{
					device.__isConnected &#x3D; false;
					internal.connectedDevices[device.address] &#x3D; null;

					// TODO: Perhaps this should be redesigned, as disconnect is
					// more of a status change than an error? What do you think?
					fail &amp;amp;&amp;amp; fail(evothings.easyble.error.DISCONNECTED);
				}
			},
			// Error callback.
			function(errorCode)
			{
				// DEBUG LOG
				console.log(&#x27;BLE connect error: &#x27; + errorCode);
			
				// Set isConnected to false on error.
				device.__isConnected &#x3D; false;
				internal.connectedDevices[device.address] &#x3D; null;
				fail(errorCode);
			});
	};
	
	/**
	 * Obtain device services, them read characteristics and descriptors
	 * for the services with the given uuid(s).
	 * If serviceUUIDs is null, info is read for all services.
 	 * Called from evothings.easyble.EasyBLEDevice.
	 * @private
	 */
	internal.readServices &#x3D; function(device, serviceUUIDs, success, fail)
	{
		// Read services.
		evothings.ble.services(
			device.deviceHandle,
			function(services)
			{
				// Array that stores services.
				device.__services &#x3D; [];

				for (var i &#x3D; 0; i &amp;lt; services.length; ++i)
				{
					var service &#x3D; services[i];
					service.uuid &#x3D; service.uuid.toLowerCase();
					device.__services.push(service);
					device.__uuidMap[service.uuid] &#x3D; service;
				}

				internal.readCharacteristicsForServices(
					device, serviceUUIDs, success, fail);
			},
			function(errorCode)
			{
				fail(errorCode);
			});
	};

	/**
	 * Read characteristics and descriptors for the services with the given uuid(s).
	 * If serviceUUIDs is null, info for all services are read.
	 * Internal function.
 	 * Called from evothings.easyble.EasyBLEDevice.
	 * @private
	 */
	internal.readCharacteristicsForServices &#x3D; function(device, serviceUUIDs, success, fail)
	{
		var characteristicsCallbackFun &#x3D; function(service)
		{
			// Array with characteristics for service.
			service.__characteristics &#x3D; [];

			return function(characteristics)
			{
				--readCounter; // Decrements the count added by services.
				readCounter +&#x3D; characteristics.length;
				for (var i &#x3D; 0; i &amp;lt; characteristics.length; ++i)
				{
					var characteristic &#x3D; characteristics[i];
					characteristic.uuid &#x3D; characteristic.uuid.toLowerCase();
					service.__characteristics.push(characteristic);
					device.__uuidMap[characteristic.uuid] &#x3D; characteristic;
					device.__serviceMap[service.uuid + &#x27;:&#x27; + characteristic.uuid] &#x3D; characteristic;

					// DEBUG LOG
					//console.log(&#x27;storing service:characteristic key: &#x27; + service.uuid + &#x27;:&#x27; + characteristic.uuid);
					//if (!characteristic)
					//{
					//	console.log(&#x27;  --&gt; characteristic is null!&#x27;)
					//}

					// Read descriptors for characteristic.
					evothings.ble.descriptors(
						device.deviceHandle,
						characteristic.handle,
						descriptorsCallbackFun(service, characteristic),
						function(errorCode)
						{
							fail(errorCode);
						});
				}
			};
		};

 		/**
	 	 * @private
	 	 */
		var descriptorsCallbackFun &#x3D; function(service, characteristic)
		{
			// Array with descriptors for characteristic.
			characteristic.__descriptors &#x3D; [];

			return function(descriptors)
			{
				--readCounter; // Decrements the count added by characteristics.
				for (var i &#x3D; 0; i &amp;lt; descriptors.length; ++i)
				{
					var descriptor &#x3D; descriptors[i];
					descriptor.uuid &#x3D; descriptor.uuid.toLowerCase();
					characteristic.__descriptors.push(descriptor);
					device.__uuidMap[characteristic.uuid + &#x27;:&#x27; + descriptor.uuid] &#x3D; descriptor;
					device.__serviceMap[service.uuid + &#x27;:&#x27; + characteristic.uuid + &#x27;:&#x27; + descriptor.uuid] &#x3D; descriptor;
				}
				if (0 &#x3D;&#x3D; readCounter)
				{
					// Everything is read.
					success(device);
				}
			};
		};

		// Initialize read counter.
		readCounter &#x3D; 0;

		if (null !&#x3D; serviceUUIDs)
		{
			// Read info for service UUIDs.
			readCounter &#x3D; serviceUUIDs.length;
			for (var i &#x3D; 0; i &amp;lt; serviceUUIDs.length; ++i)
			{
				var uuid &#x3D; serviceUUIDs[i].toLowerCase();
				var service &#x3D; device.__uuidMap[uuid];
				if (!service)
				{
					fail(evothings.easyble.error.SERVICE_NOT_FOUND + &#x27; &#x27; + uuid);
					return;
				}

				// Read characteristics for service. Will also read descriptors.
				evothings.ble.characteristics(
					device.deviceHandle,
					service.handle,
					characteristicsCallbackFun(service),
					function(errorCode)
					{
						fail(errorCode);
					});
			}
		}
		else
		{
			// Read info for all services.
			readCounter &#x3D; device.__services.length;
			for (var i &#x3D; 0; i &amp;lt; device.__services.length; ++i)
			{
				// Read characteristics for service. Will also read descriptors.
				var service &#x3D; device.__services[i];
				evothings.ble.characteristics(
					device.deviceHandle,
					service.handle,
					characteristicsCallbackFun(service),
					function(errorCode)
					{
						fail(errorCode);
					});
			}
		}
	};

 	/**
 	 * Called from evothings.easyble.EasyBLEDevice.
	 * @deprecated Naming is a bit confusing, internally functions
	 * named &quot;xxxServiceYYY&quot; are the &quot;future-safe&quot; onces, but in
	 * the public API functions &quot;xxxYYY&quot; are new &quot;future-safe&quot;
	 * (and backwards compatible).
	 * @private
	 */
	internal.readCharacteristic &#x3D; function(device, characteristicUUID, success, fail)
	{
		characteristicUUID &#x3D; characteristicUUID.toLowerCase();

		var characteristic &#x3D; device.__uuidMap[characteristicUUID];
		if (!characteristic)
		{
			fail(evothings.easyble.error.CHARACTERISTIC_NOT_FOUND + &#x27; &#x27; +
				characteristicUUID);
			return;
		}

		evothings.ble.readCharacteristic(
			device.deviceHandle,
			characteristic.handle,
			success,
			fail);
	};

	/**
	 * Called from evothings.easyble.EasyBLEDevice.
	 * @private
	 */
	internal.readServiceCharacteristic &#x3D; function(
		device, serviceUUID, characteristicUUID, success, fail)
	{
		var key &#x3D; serviceUUID.toLowerCase() + &#x27;:&#x27; + characteristicUUID.toLowerCase();

		var characteristic &#x3D; device.__serviceMap[key];
		if (!characteristic)
		{
			fail(evothings.easyble.error.CHARACTERISTIC_NOT_FOUND + &#x27; &#x27; + key);
			return;
		}

		evothings.ble.readCharacteristic(
			device.deviceHandle,
			characteristic.handle,
			success,
			fail);
	};

 	/**
 	 * Called from evothings.easyble.EasyBLEDevice.
	 * @deprecated Naming is a bit confusing, internally functions
	 * named &quot;xxxServiceYYY&quot; are the &quot;future-safe&quot; onces, but in
	 * the public API functions &quot;xxxYYY&quot; are new &quot;future-safe&quot;
	 * (and backwards compatible).
	 * @private
	 */
	internal.readDescriptor &#x3D; function(
		device, characteristicUUID, descriptorUUID, success, fail)
	{
		characteristicUUID &#x3D; characteristicUUID.toLowerCase();
		descriptorUUID &#x3D; descriptorUUID.toLowerCase();

		var descriptor &#x3D; device.__uuidMap[characteristicUUID + &#x27;:&#x27; + descriptorUUID];
		if (!descriptor)
		{
			fail(evothings.easyble.error.DESCRIPTOR_NOT_FOUND + &#x27; &#x27; + descriptorUUID);
			return;
		}

		evothings.ble.readDescriptor(
			device.deviceHandle,
			descriptor.handle,
			success,
			fail);
	};

	/**
	 * Called from evothings.easyble.EasyBLEDevice.
	 * @private
	 */
	internal.readServiceDescriptor &#x3D; function(
		device, serviceUUID, characteristicUUID, descriptorUUID, success, fail)
	{
		var key &#x3D; serviceUUID.toLowerCase() + &#x27;:&#x27; +
			characteristicUUID.toLowerCase() + &#x27;:&#x27; +
			descriptorUUID.toLowerCase();

		var descriptor &#x3D; device.__serviceMap[key];
		if (!descriptor)
		{
			fail(evothings.easyble.error.DESCRIPTOR_NOT_FOUND + &#x27; &#x27; + key);
			return;
		}

		evothings.ble.readDescriptor(
			device.deviceHandle,
			descriptor.handle,
			success,
			fail);
	};

 	/**
 	 * Called from evothings.easyble.EasyBLEDevice.
	 * @deprecated Naming is a bit confusing, internally functions
	 * named &quot;xxxServiceYYY&quot; are the &quot;future-safe&quot; onces, but in
	 * the public API functions &quot;xxxYYY&quot; are new &quot;future-safe&quot;
	 * (and backwards compatible).
	 * @private
	 */
	internal.writeCharacteristic &#x3D; function(
		device, characteristicUUID, value, success, fail)
	{
		characteristicUUID &#x3D; characteristicUUID.toLowerCase();

		var characteristic &#x3D; device.__uuidMap[characteristicUUID];
		if (!characteristic)
		{
			fail(evothings.easyble.error.CHARACTERISTIC_NOT_FOUND + &#x27; &#x27; +
				characteristicUUID);
			return;
		}

		evothings.ble.writeCharacteristic(
			device.deviceHandle,
			characteristic.handle,
			value,
			function()
			{
				success();
			},
			function(errorCode)
			{
				fail(errorCode);
			});
	};

	/**
	* Called from evothings.easyble.EasyBLEDevice.
	* @private
	*/
	internal.writeServiceCharacteristic &#x3D; function(
		device, serviceUUID, characteristicUUID, value, success, fail)
	{
		var key &#x3D; serviceUUID.toLowerCase() + &#x27;:&#x27; + characteristicUUID.toLowerCase();

		var characteristic &#x3D; device.__serviceMap[key];
		if (!characteristic)
		{
			fail(evothings.easyble.error.CHARACTERISTIC_NOT_FOUND + &#x27; &#x27; + key);
			return;
		}

		evothings.ble.writeCharacteristic(
			device.deviceHandle,
			characteristic.handle,
			value,
			success,
			fail);
	};

	/**
	* Called from evothings.easyble.EasyBLEDevice.
	* @private
	*/
	internal.writeServiceCharacteristicWithoutResponse &#x3D; function(
		device, serviceUUID, characteristicUUID, value, success, fail)
	{
		var key &#x3D; serviceUUID.toLowerCase() + &#x27;:&#x27; + characteristicUUID.toLowerCase();

		// DEBUG LOG
		//console.log(&#x27;internal.writeServiceCharacteristicWithoutResponse key: &#x27; + key)
		//console.log(&#x27;internal.writeServiceCharacteristicWithoutResponse serviceMap:&#x27;)
		for (var theKey in device.__serviceMap)
		{
			console.log(&#x27;  &#x27; + theKey);
		}

		var characteristic &#x3D; device.__serviceMap[key];
		if (!characteristic)
		{
			fail(evothings.easyble.error.CHARACTERISTIC_NOT_FOUND + &#x27; &#x27; + key);
			return;
		}

		evothings.ble.writeCharacteristicWithoutResponse(
			device.deviceHandle,
			characteristic.handle,
			value,
			success,
			fail);
	};

 	/**
 	 * Called from evothings.easyble.EasyBLEDevice.
	 * @deprecated Naming is a bit confusing, internally functions
	 * named &quot;xxxServiceYYY&quot; are the &quot;future-safe&quot; onces, but in
	 * the public API functions &quot;xxxYYY&quot; are new &quot;future-safe&quot;
	 * (and backwards compatible).
	 * @private
	 */
	internal.writeDescriptor &#x3D; function(
		device, characteristicUUID, descriptorUUID, value, success, fail)
	{
		characteristicUUID &#x3D; characteristicUUID.toLowerCase();
		descriptorUUID &#x3D; descriptorUUID.toLowerCase();

		var descriptor &#x3D; device.__uuidMap[characteristicUUID + &#x27;:&#x27; + descriptorUUID];
		if (!descriptor)
		{
			fail(evothings.easyble.error.DESCRIPTOR_NOT_FOUND + &#x27; &#x27; + descriptorUUID);
			return;
		}

		evothings.ble.writeDescriptor(
			device.deviceHandle,
			descriptor.handle,
			value,
			function()
			{
				success();
			},
			function(errorCode)
			{
				fail(errorCode);
			});
	};

	/**
	 * Called from evothings.easyble.EasyBLEDevice.
	 * @private
	 */
	internal.writeServiceDescriptor &#x3D; function(
		device, serviceUUID, characteristicUUID, descriptorUUID, value, success, fail)
	{
		var key &#x3D; serviceUUID.toLowerCase() + &#x27;:&#x27; +
			characteristicUUID.toLowerCase() + &#x27;:&#x27; +
			descriptorUUID.toLowerCase();

		var descriptor &#x3D; device.__serviceMap[key];
		if (!descriptor)
		{
			fail(evothings.easyble.error.DESCRIPTOR_NOT_FOUND + &#x27; &#x27; + key);
			return;
		}

		evothings.ble.writeDescriptor(
			device.deviceHandle,
			descriptor.handle,
			value,
			success,
			fail);
	};

 	/**
 	 * Called from evothings.easyble.EasyBLEDevice.
	 * @deprecated Naming is a bit confusing, internally functions
	 * named &quot;xxxServiceYYY&quot; are the &quot;future-safe&quot; onces, but in
	 * the public API functions &quot;xxxYYY&quot; are new &quot;future-safe&quot;
	 * (and backwards compatible).
	 * @private
	 */
	internal.enableNotification &#x3D; function(
		device, characteristicUUID, success, fail, options)
	{
		characteristicUUID &#x3D; characteristicUUID.toLowerCase();

		var characteristic &#x3D; device.__uuidMap[characteristicUUID];
		if (!characteristic)
		{
			fail(evothings.easyble.error.CHARACTERISTIC_NOT_FOUND + &#x27; &#x27; +
				characteristicUUID);
			return;
		}

		evothings.ble.enableNotification(
			device.deviceHandle,
			characteristic.handle,
			success,
			fail,
			options);
	};

	/**
	 * Called from evothings.easyble.EasyBLEDevice.
	 * @private
	 */
	internal.enableServiceNotification &#x3D; function(
		device, serviceUUID, characteristicUUID, success, fail, options)
	{
		var key &#x3D; serviceUUID.toLowerCase() + &#x27;:&#x27; + characteristicUUID.toLowerCase();

		var characteristic &#x3D; device.__serviceMap[key];
		if (!characteristic)
		{
			fail(evothings.easyble.error.CHARACTERISTIC_NOT_FOUND + &#x27; &#x27; + key);
			return;
		}

		evothings.ble.enableNotification(
			device.deviceHandle,
			characteristic.handle,
			success,
			fail,
			options);
	};

 	/**
 	 * Called from evothings.easyble.EasyBLEDevice.
	 * @deprecated Naming is a bit confusing, internally functions
	 * named &quot;xxxServiceYYY&quot; are the &quot;future-safe&quot; onces, but in
	 * the public API functions &quot;xxxYYY&quot; are new &quot;future-safe&quot;
	 * (and backwards compatible).
	 * @private
	 */
	internal.disableNotification &#x3D; function(
		device, characteristicUUID, success, fail, options)
	{
		characteristicUUID &#x3D; characteristicUUID.toLowerCase();

		var characteristic &#x3D; device.__uuidMap[characteristicUUID];
		if (!characteristic)
		{
			fail(evothings.easyble.error.CHARACTERISTIC_NOT_FOUND + &#x27; &#x27; +
				characteristicUUID);
			return;
		}

		evothings.ble.disableNotification(
			device.deviceHandle,
			characteristic.handle,
			success,
			fail,
			options);
	};

	/**
	 * Called from evothings.easyble.EasyBLEDevice.
	 * @private
	 */
	internal.disableServiceNotification &#x3D; function(
		device, serviceUUID, characteristicUUID, success, fail, options)
	{
		var key &#x3D; serviceUUID.toLowerCase() + &#x27;:&#x27; + characteristicUUID.toLowerCase();

		var characteristic &#x3D; device.__serviceMap[key];
		if (!characteristic)
		{
			fail(evothings.easyble.error.CHARACTERISTIC_NOT_FOUND + &#x27; &#x27; + key);
			return;
		}

		evothings.ble.disableNotification(
			device.deviceHandle,
			characteristic.handle,
			success,
			fail,
			options);
	};

	/**
	 * Prints and object for debugging purposes.
	 * @deprecated. Defined here for backwards compatibility.
	 * Use evothings.printObject().
	 * @public
	 */
	evothings.easyble.printObject &#x3D; evothings.printObject;

 	/**
 	 * Reset the BLE hardware. Can be time consuming.
	 * @public
	 */
	evothings.easyble.reset &#x3D; function()
	{
		evothings.ble.reset();
	};
})();
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 3.4.0 on October 18, 2016.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/jquery.cookie.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>